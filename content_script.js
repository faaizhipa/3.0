// --- METADATA ---

/**
 * @constant {string} emailEndNote
 * @description The primary support email for EndNote.
 */
const emailEndNote = "endnote.support@clarivate.com"

/**
 * @constant {string[]} emailKeywordsEndNote
 * @description Keywords used to identify emails that should not be sent from the EndNote queue.
 */
const emailKeywordsEndNote = [
  'ts.',
  'ts-',
  'techstreet',
  'account',
  'tr.',
  'queries',
  'jgear',
  'jstead',
  'derwent',
  'customer',
  'scientific',
  'proposals',
  'service',
  'science',
  'custserv',
  'wos', 'WOS',
  'collections',
  'invoices',
  'serion',
  'services',
  'compumark',
  'admin',
  'contract',
  'ipsci',
  'ips',
  'drg',
  'dartsip',
  'hidadataprogram',
  'cortellis',
  'compuMark',
  'account',
  'billing',
  'invoice',
  'certificate',
  'tax',
  'support',
  'askhbi',
  'cash',
  'team',
  'sales',
  'bis.in', 'bis.mon',
  'bisqa',
];

/**
 * @constant {string} emailWoS
 * @description The primary support email for Web of Science.
 */
const emailWoS = "wosg.support@clarivate.com"
/**
 * @constant {string[]} emailKeywordsWoS
 * @description Keywords used to identify emails that should not be sent from the Web of Science queue.
 */
const emailKeywordsWoS = [
  'ts.',
  'ts-',
  'techstreet',
  'account',
  'tr.',
  'queries',
  'jgear',
  'jstead',
  'derwent',
  'customer',
  'scientific',
  'proposals',
  'service',
  'custserv',
  'endnote',
  'collections',
  'invoices',
  'serion',
  'services',
  'compumark',
  'admin',
  'contract',
  'ipsci',
  'ips',
  'drg',
  'dartsip',
  'hidadataprogram',
  'cortellis',
  'compuMark',
  'account',
  'billing',
  'invoice',
  'certificate',
  'tax',
  'support',
  'askhbi',
  'cash',
  'team',
  'sales',
  'bis.in', 'bis.mon',
  'bisqa',
];

/**
 * @constant {string} emailScholarOne
 * @description The primary support email for ScholarOne.
 */
const emailScholarOne = "s1help@clarivate.com";
/**
 * @constant {string[]} emailKeywordsScholarOne
 * @description Keywords used to identify emails that should not be sent from the ScholarOne queue.
 */
const emailKeywordsScholarOne = [
  'ts.',
  'ts-',
  'techstreet',
  'account',
  'tr.',
  'queries',
  'wos', 'WOS',
  'jgear',
  'jstead',
  'derwent',
  'customer',
  'scientific',
  'proposals',
  'service',
  'custserv',
  'endnote',
  'collections',
  'invoices',
  'serion',
  'services',
  'compumark',
  'admin',
  'contract',
  'ipsci',
  'ips',
  'drg',
  'dartsip',
  'hidadataprogram',
  'cortellis',
  'compuMark',
  'account',
  'billing',
  'invoice',
  'certificate',
  'tax',
  'support',
  'askhbi',
  'cash',
  'team',
  'sales',
  'bis.in', 'bis.mon',
  'bisqa',
];

/**
 * @constant {string} emailAccountSupport
 * @description The primary support email for Account Support.
 */
const emailAccountSupport = "account.support@clarivate.com"
/**
 * @constant {string[]} emailKeywordsAccountSupport
 * @description Keywords used to identify emails that should not be sent from the Account Support queue.
 */
const emailKeywordsAccountSupport = [
  'ts.',
  'ts-',
  'techstreet',
  'endnote',
  'tr.',
  'queries',
  'jgear',
  'jstead',
  'derwent',
  'customer',
  'scientific',
  'proposals',
  'service',
  'science',
  'custserv',
  'wos', 'WOS',
  'collections',
  'invoices',
  'serion',
  'services',
  'compumark',
  'admin',
  'contract',
  'ipsci',
  'ips',
  'drg',
  'dartsip',
  'hidadataprogram',
  'cortellis',
  'compuMark',
  'account',
  'billing',
  'invoice',
  'certificate',
  'tax',
  'support',
  'askhbi',
  'cash',
  'team',
  'sales',
  'bis.in', 'bis.mon',
  'bisqa',
];

/**
 * @constant {string} emailLifeScience
 * @description The primary support email for Life Science.
 */
const emailLifeScience = "lifesciences.support@clarivate.com"
/**
 * @constant {string[]} emailKeywordsLifeScience
 * @description Keywords used to identify emails that should not be sent from the Life Science queue.
 */
const emailKeywordsLifeScience = [
  'ts.',
  'ts-',
  'techstreet',
  'endnote',
  'science',
  'tr.',
  'queries',
  'jgear',
  'jstead',
  'derwent',
  'customer',
  'scientific',
  'proposals',
  'service',
  'science',
  'custserv',
  'wos', 'WOS',
  'collections',
  'invoices',
  'serion',
  'services',
  'compumark',
  'admin',
  'contract',
  'ipsci',
  'ips',
  'drg',
  'dartsip',
  'hidadataprogram',
  'cortellis',
  'compuMark',
  'account',
  'billing',
  'invoice',
  'certificate',
  'tax',
  'support',
  'askhbi',
  'cash',
  'team',
  'sales',
  'bis.in', 'bis.mon',
  'bisqa',
];

/**
 * @constant {string} emailLifeScienceHDS
 * @description The primary support email for Life Science HDS.
 */
const emailLifeScienceHDS = "DRG.customerservice@clarivate.com"
/**
 * @constant {string[]} emailKeywordsLifeScienceHDS
 * @description Keywords used to identify emails that should not be sent from the Life Science HDS queue.
 */
const emailKeywordsLifeScienceHDS = [
  'ts.',
  'ts-',
  'techstreet',
  'endnote',
  'science',
  'tr.',
  'queries',
  'jgear',
  'jstead',
  'derwent',
  'customer',
  'scientific',
  'proposals',
  'service',
  'science',
  'custserv',
  'wos', 'WOS',
  'collections',
  'invoices',
  'serion',
  'services',
  'compumark',
  'admin',
  'contract',
  'ipsci',
  'ips',
  'drg',
  'dartsip',
  'hidadataprogram',
  'cortellis',
  'compuMark',
  'account',
  'billing',
  'invoice',
  'certificate',
  'tax',
  'support',
  'askhbi',
  'cash',
  'team',
  'sales',
  'bis.in', 'bis.mon',
  'bisqa',
];

/**
 * @constant {string[]} emailLifeSciencePS
 * @description The primary support emails for Life Science PS.
 */
const emailLifeSciencePS = ["lsclientservicesdl@clarivate.com", "lifesciences.support@clarivate.com"]
/**
 * @constant {string[]} emailKeywordsLifeSciencePS
 * @description Keywords used to identify emails that should not be sent from the Life Science PS queue.
 */
const emailKeywordsLifeSciencePS = [
  'ts.',
  'ts-',
  'techstreet',
  'endnote',
  'science',
  'tr.',
  'queries',
  'jgear',
  'jstead',
  'derwent',
  'customer',
  'scientific',
  'proposals',
  'service',
  'science',
  'custserv',
  'wos', 'WOS',
  'collections',
  'invoices',
  'serion',
  'services',
  'compumark',
  'admin',
  'contract',
  'ipsci',
  'ips',
  'drg',
  'dartsip',
  'hidadataprogram',
  'cortellis',
  'compuMark',
  'account',
  'billing',
  'invoice',
  'certificate',
  'tax',
  'support',
  'askhbi',
  'cash',
  'team',
  'sales',
  'bis.in', 'bis.mon',
  'bisqa',
];

let desiredTextSelection, emailKeywordsSelection;

/**
 * @description Retrieves the user's saved team selection from Chrome's storage and sets the
 * `desiredTextSelection` and `emailKeywordsSelection` variables accordingly.
 */
chrome.runtime.sendMessage({ message: 'getSavedSelection' }, function (response) {
  if (response.status) {
    const savedSelection = response.data;

    // Based on the saved selection, set the desiredText and emailKeywords
    if (savedSelection === 'EndNote') {
      desiredTextSelection = emailEndNote;
      emailKeywordsSelection = emailKeywordsEndNote;
    } else if (savedSelection === 'ScholarOne') {
      desiredTextSelection = emailScholarOne;
      emailKeywordsSelection = emailKeywordsScholarOne;
    } else if (savedSelection === 'WebOfScience') {
      desiredTextSelection = emailWoS;
      emailKeywordsSelection = emailKeywordsWoS;
    } else if (savedSelection === 'AccountSupport') {
      desiredTextSelection = emailAccountSupport;
      emailKeywordsSelection = emailKeywordsAccountSupport;
    } else if (savedSelection === 'LifeScience') {
      desiredTextSelection = emailLifeScience;
      emailKeywordsSelection = emailKeywordsLifeScience;
    } else if (savedSelection === 'LifeScienceHDS') {
      desiredTextSelection = emailLifeScienceHDS;
      emailKeywordsSelection = emailKeywordsLifeScienceHDS;
    } else if (savedSelection === 'LifeSciencePS') {
      desiredTextSelection = emailLifeSciencePS;
      emailKeywordsSelection = emailKeywordsLifeSciencePS;
    }

  } else {
    console.error('Error retrieving selection:', response.error);
  }
});


// --- FROM EMAIL HIGHLIGHTER ---

// Function to check if the anchor's content matches the specific text
/* function isEndNoteSupportAnchor(anchor) {
  
  const desiredText = desiredTextSelection || emailEndNote;
  return anchor.textContent.includes(desiredText);
}
 */

// > For SFDC Classic (ScholarOne)

/**
 * @description Checks if the current page is the email sending page in Salesforce Classic.
 * @returns {boolean} True if the page is the email page, false otherwise.
 */
function emailPageCheck() {
  let h1Elements = document.getElementsByTagName('h1');

  let result = false;

  for (let h1Element of h1Elements) {
    if (h1Element.className == 'pageType' && h1Element.textContent == 'Email Message:') {
      result = true;
      break;
    }
  }

  console.log(result);

  return result;
}

/**
 * @description Changes the background color of the 'From' email dropdown in Salesforce Classic (ScholarOne)
 * based on the selected email template. It highlights incorrect selections.
 */
function changeS1AnchorBackgroundColor() {

  var selectEmailElement = document.querySelector('select#p26');

  if (selectEmailElement.selectedIndex === 0) {
    selectEmailElement.style.backgroundColor = "#ff9eb6";
    console.log('color changed to red');
  } else if (selectEmailElement.selectedIndex === 11) {
    selectEmailElement.style.backgroundColor = "";
    console.log('color changed to normal');
  } else {
    selectEmailElement.style.backgroundColor = "#ffd676";
    console.log('color changed to orange');
  }

}

/**
 * @description Main handler for email-related functionality on ScholarOne Salesforce Classic pages.
 * It checks if the current page is the email page and, if so, applies the initial
 * background color change and sets up an event listener for future changes.
 */
function scholarOneHandleAnchor() {
  if (emailPageCheck()) {

    // runs the backgroundcolourchange for ScholarOne SFDC once initially.
    changeS1AnchorBackgroundColor();

    document.querySelector('select#p26').addEventListener('change', function () {
      changeS1AnchorBackgroundColor();
      console.log('The selected option has changed.');

    });
  }
}

// > For SFDC Lightning

/**
 * @description Checks if an anchor element's text content matches the desired support email.
 * This function handles cases where the desired email is a single string or an array of strings.
 * @param {HTMLAnchorElement} anchor - The anchor element to check.
 * @returns {boolean} True if the anchor text contains the desired email, false otherwise.
 */
function isEndNoteSupportAnchor(anchor) {
  let desiredText = desiredTextSelection || emailEndNote;

  // Check if desiredText is an array
  if (Array.isArray(desiredText)) {
    // Loop through each item in the array
    for (let item of desiredText) {
      if (anchor.textContent.includes(item)) {
        return true;  // Return true if any item is included in the anchor's textContent
      }
    }
    return false;  // Return false if none of the items are included
  } else {
    // If desiredText is not an array, proceed as before
    return anchor.textContent.includes(desiredText);
  }
}

/**
 * @description Checks if an anchor's text content contains any of the keywords for non-support emails
 * and the "@clarivate.com" domain. This is used to identify internal or mis-queued emails.
 * @param {HTMLAnchorElement} anchor - The anchor element to check.
 * @returns {boolean} True if a keyword and the domain are found, false otherwise.
 */
function isClarivateEmailList(anchor) {
  const emailKeywords = emailKeywordsSelection || emailKeywordsEndNote;

  const clarivateDomain = '@clarivate.com';

  for (let keyword of emailKeywords) {
    if (anchor.textContent.includes(keyword) && anchor.textContent.includes(clarivateDomain)) {
      return true;
    }
  }

  return false;
}


/**
 * @description Sets the background color of an element.
 * @param {HTMLElement} anchor - The element to highlight.
 * @param {string} color - The color to set as the background.
 */
function highlightAnchorWithSpecificContent(anchor, color) {
  anchor.style.backgroundColor = color;
}

/**
 * @description Removes the background color from an element.
 * @param {HTMLElement} anchor - The element to unhighlight.
 */
function unhighlightAnchor(anchor) {
  anchor.style.backgroundColor = "";
}

/**
 * @description Main function to handle the "From" email field highlighting in Salesforce Lightning.
 * It identifies the correct "From" field, checks the selected email, and applies highlighting
 * for incorrect or non-standard selections.
 */
function handleAnchors() {
  const fromFieldDiv = document.getElementsByClassName("standardField uiMenu");
  for (const fromDiv of fromFieldDiv) {
    const anchor = fromDiv.querySelector("a.select");
    if (!isEndNoteSupportAnchor(anchor)) {
      if (!isClarivateEmailList(anchor)) {
        highlightAnchorWithSpecificContent(anchor, "red");
      } else {
        highlightAnchorWithSpecificContent(anchor, "orange");
      }
    } else {
      unhighlightAnchor(anchor);
    }
  }
}

// --- OPEN CASES HIGHLIGHTER ---

/**
 * @description Compares two date strings and returns the earlier date.
 * @param {string} date1Str - The first date string.
 * @param {string} date2Str - The second date string.
 * @returns {Date} The earlier of the two dates.
 */
function getEarlierDate(date1Str, date2Str) {
  const date1 = new Date(date1Str);
  const date2 = new Date(date2Str);

  if (date1 < date2) {

    return date1;
  } else {

    return date2;
  }
}

/**
 * @description Calculates the difference in minutes between a given date and the current time.
 * @param {Date|string} date - The date to compare with now.
 * @returns {number} The time difference in minutes.
 */
function calculateTimeDifferenceInMinutes(date) {
  const openDate = new Date(date);
  const currentDate = new Date();

  const timeDifferenceInMilliseconds = Math.abs(currentDate - openDate);
  const timeDifferenceInMinutes = timeDifferenceInMilliseconds / (1000 * 60);

  return timeDifferenceInMinutes;
}

/**
 * @description Checks if a string is a valid date in MM/DD/YYYY HH:MM AM/PM format.
 * @param {string} textContent - The string to validate.
 * @returns {boolean} True if the string matches the date format, false otherwise.
 */
function isValidDateFormat(textContent) {
  const datePattern = /^(1[0-2]|0?[1-9])\/(3[01]|[12][0-9]|0?[1-9])\/\d{4} (1[0-2]|0?[1-9]):([0-5][0-9]) (AM|PM)$/;

  return datePattern.test(textContent);
}

/**
 * @description Checks if a string is a valid date in DD/MM/YYYY HH:MM AM/PM format.
 * @param {string} textContent - The string to validate.
 * @returns {boolean} True if the string matches the date format, false otherwise.
 */
function isValidDateFormat2(textContent) {
  const datePattern = /^(3[01]|[12][0-9]|0?[1-9])\/(1[0-2]|0?[1-9])\/\d{4} (1[0-2]|0?[1-9]):([0-5][0-9]) (AM|PM)$/;

  return datePattern.test(textContent);
}

/**
 * @description Checks if a string is a valid date in DD/MM/YYYY HH:MM (24-hour) format.
 * @param {string} textContent - The string to validate.
 * @returns {boolean} True if the string matches the date format, false otherwise.
 */
function isValidDateFormatDDMMnoAMPM(textContent) {
  const datePattern = /^(0?[1-9]|[12][0-9]|3[01])\/(0?[1-9]|1[012])\/\d{4} ([01]?[0-9]|2[0-3]):[0-5][0-9]$/;

  return datePattern.test(textContent);
}

/**
 * @description Checks if a string is a valid date in MM/DD/YYYY HH:MM (24-hour) format.
 * @param {string} textContent - The string to validate.
 * @returns {boolean} True if the string matches the date format, false otherwise.
 */
function isValidDateFormatMMDDnoAMPM(textContent) {
  const datePattern = /^(0?[1-9]|1[0-2])\/(0?[1-9]|[12][0-9]|3[01])\/\d{4} ([01]?[0-9]|2[0-3]):[0-5][0-9]$/;
  return datePattern.test(textContent);
}


/**
 * @description Converts a date string from DD/MM/YYYY to MM/DD/YYYY format.
 * @param {string} inputDate - The date string to convert.
 * @returns {string} The converted date string.
 */
function convertDateFormat2(inputDate) {
  // Split the input date string into date and time parts
  const [datePart, timePart, isAmPm] = inputDate.split(' ');

  // Split the date part into day, month, and year
  const [day, month, year] = datePart.split('/');

  // Rearrange the parts into the desired format
  const outputDate = `${month}/${day}/${year} ${timePart} ${isAmPm}`;

  return outputDate;
}

/**
 * @description Gets the current day of the month.
 * @returns {number} The day of the month (1-31).
 */
function getDayOfMonth() {
  // Create a new Date object to get the current date
  var currentDate = new Date();

  // Get the day of the month (1-31)
  var dayOfMonth = currentDate.getDate();

  // Output the day of the month
  return dayOfMonth;
}

/**
 * @description Gets the current month.
 * @returns {number} The month (1-12).
 */
function getCurrentMonth() {
  // Create a new Date object to get the current date
  var currentDate = new Date();

  // Get the month (0-11)
  var month = currentDate.getMonth() + 1;

  // Output the month
  return month;
}

/**
 * @description Gets the current four-digit year.
 * @returns {number} The current year.
 */
function getCurrentYear() {
  // Create a new Date object to get the current date
  var currentDate = new Date();

  // Get the four digit year (yyyy)
  var year = currentDate.getFullYear();

  // Output the year
  return year;
}

/**
 * @description Converts a date string from DD/MM/YYYY HH:MM (24-hour) to MM/DD/YYYY HH:MM AM/PM format.
 * @param {string} dateString - The date string to convert.
 * @returns {string} The converted date string.
 */
function convertDateFormatDDMMwithAMPM(dateString) {
  // Split the date and time parts
  const [datePart, timePart] = dateString.split(' ');

  // Split the date into day, month, and year
  const [day, month, year] = datePart.split('/').map(Number);

  // Split the time into hours and minutes
  const [hours, minutes] = timePart.split(':').map(Number);

  // Create a new Date object
  const date = new Date(year, month - 1, day, hours, minutes);

  // Format hours for AM/PM
  const hours12 = date.getHours() % 12 || 12;
  const amPm = date.getHours() < 12 ? 'AM' : 'PM';

  // Format the date string
  return `${String(month).padStart(2, '0')}/${String(day).padStart(2, '0')}/${year} ` +
    `${String(hours12).padStart(2, '0')}:${String(minutes).padStart(2, '0')} ${amPm}`;
}

/**
 * @description Converts a date string from MM/DD/YYYY HH:MM (24-hour) to MM/DD/YYYY HH:MM AM/PM format.
 * @param {string} dateString - The date string to convert.
 * @returns {string} The converted date string.
 */
function convertDateFormatMMDDwithAMPM(dateString) {
  const [datePart, timePart] = dateString.split(' ');
  const [month, day, year] = datePart.split('/');
  const [hours, minutes] = timePart.split(':');

  // Create a new Date object
  const date = new Date(year, month - 1, day, hours, minutes);

  // Format the date into MM/DD/YYYY HH:MM AM/PM
  const formattedDate = date.toLocaleString('en-US', {
    month: '2-digit',
    day: '2-digit',
    year: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
    hour12: true
  });

  return formattedDate;
}

/**
 * @description Intelligently converts a date string that could be in either DD/MM/YYYY or MM/DD/YYYY format
 * to a standardized MM/DD/YYYY HH:MM AM/PM format. It uses heuristics to determine the original format.
 * @param {string} inputDate - The date string to convert.
 * @returns {string} The standardized date string.
 */
function convertDateFormat(inputDate) {
  // Split the input date string into date and time parts
  const [datePart, timePart, isAmPm] = inputDate.split(' ');

  // Split the date part into day, month, and year
  const [firstDatePart, secondDatePart, year] = datePart.split('/');

  const currentDayOfMonth = getDayOfMonth();
  //console.log('currentDayOfMonth!!', currentDayOfMonth)
  const currentMonth = getCurrentMonth();
  //console.log('currentMonth!!', currentMonth)

  let day, month;

  // Check if the first part of the date is the day of the month
  if ((firstDatePart == currentDayOfMonth) && (secondDatePart == currentMonth)) {
    day = firstDatePart;
    month = secondDatePart;
    //console.log('firstDatePart', firstDatePart, 'secondDatePart', secondDatePart, 'day', day, 'month', month);
    //console.log('FIRST: firstDatePart === currentDayOfMonth && secondDatePart === currentMonth');
  } else if ((firstDatePart == currentMonth) && (secondDatePart == currentDayOfMonth)) {
    day = secondDatePart;
    month = firstDatePart;
    //console.log('firstDatePart', firstDatePart, 'secondDatePart', secondDatePart, 'day', day, 'month', month);
    //console.log('SECOND: firstDatePart === currentMonth && secondDatePart === currentDayOfMonth');
  } else if ((firstDatePart > 12) && (secondDatePart <= 12)) {
    day = firstDatePart;
    month = secondDatePart;
    //console.log('firstDatePart', firstDatePart, 'secondDatePart', secondDatePart, 'day', day, 'month', month);
    //console.log('THIRD: firstDatePart > 12 && secondDatePart <= 12');
  } else if ((firstDatePart <= 12) && (secondDatePart > 12)) {
    day = secondDatePart;
    month = firstDatePart;
    //console.log('firstDatePart', firstDatePart, 'secondDatePart', secondDatePart, 'day', day, 'month', month);
    //console.log('FOURTH: firstDatePart <= 12 && secondDatePart > 12');
  } else if ((firstDatePart > currentMonth) && (secondDatePart <= 12)) {
    day = firstDatePart;
    month = secondDatePart;
    //console.log('firstDatePart', firstDatePart, 'secondDatePart', secondDatePart, 'day', day, 'month', month);
    //console.log('FIFTH: firstDatePart > currentMonth && secondDatePart <= 12');
  } else if ((secondDatePart > currentMonth) && (firstDatePart <= 12)) {
    day = secondDatePart;
    month = firstDatePart;
    //console.log('firstDatePart', firstDatePart, 'secondDatePart', secondDatePart, 'day', day, 'month', month);
    //console.log('SIXTH: secondDatePart > currentMonth && firstDatePart <= 12');
  } else {
    month = firstDatePart;
    day = secondDatePart;
    //console.log('firstDatePart', firstDatePart, 'secondDatePart', secondDatePart, 'day', day, 'month', month);
    //console.log('SEVENTH: No Change');
  }

  // Rearrange the parts into the desired format
  const outputDate = `${month}/${day}/${year} ${timePart} ${isAmPm}`;

  //console.log('outputDate', outputDate);
  return outputDate;
}

/**
 * @description Checks if a table row represents a case with a status of "Open" or "New", but not "Re-opened".
 * @param {HTMLTableRowElement} rowElement - The table row element to check.
 * @returns {boolean} True if the case status is "Open" or "New", but not "Re-opened".
 */
function hasOpenButNotReopened(rowElement) {
  const statusElements = rowElement.querySelectorAll("td span span");
  let isOpenFound = false;
  let isReopenedFound = false;

  statusElements.forEach(element => {
    const textContent = element.textContent.trim();

    if (textContent === "Open") {
      isOpenFound = true;
    } else if (textContent === "Re-opened") {
      isReopenedFound = true;
    } else if (textContent === "New") {
      return true;
    }
  });

  if (isOpenFound && !isReopenedFound) {
    return true
  } else {
    return false;
  }
}

/**
 * @description Main function for the "Open Cases Highlighter" feature. It scans tables for open cases,
 * parses date/time information, calculates the age of the case, and highlights the row based on how
 * long it has been open.
 */
function handleCases() {
  let webTables = document.querySelectorAll('table');

  for (let table of webTables) {
    const rows = table.querySelector('tbody').querySelectorAll('tr');
    for (let row of rows) {
      // check if the row has the term "Open" but not "Re-opened"
      if (hasOpenButNotReopened(row)) {
        const dateArray = [];
        const dateElements = row.querySelectorAll("td span span");

        // check if there's any textContent with the correct format, and push it to dateArray if it is
        dateElements.forEach(element => {
          const textContent = element.textContent;

          if (isValidDateFormat(textContent)) {
            // if the date format is MM/DD/YYYY, push it to dateArray
            const convertedDate = convertDateFormat(textContent);
            dateArray.push(convertedDate);
            //console.log('isValidDateFormat ONE has run')
          } else if (isValidDateFormat2(textContent)) {
            // if the date format is DD/MM/YYYY, convert it to MM/DD/YYYY and push it to dateArray
            const convertedDate = convertDateFormat2(textContent);
            dateArray.push(convertedDate);
            //console.log('isValidDateFormat2 TWO has run')
          } else if (isValidDateFormatDDMMnoAMPM(textContent)) {
            const addAMPM = convertDateFormatDDMMwithAMPM(textContent);
            // console.log(addAMPM);
            const convertedDate = convertDateFormat(addAMPM);
            dateArray.push(convertedDate);
          } else if (isValidDateFormatMMDDnoAMPM(textContent)) {
            const addAMPM = convertDateFormatMMDDwithAMPM(textContent);
            // console.log(addAMPM);
            const convertedDate = convertDateFormat(addAMPM);
            dateArray.push(convertedDate);
          }
        });

        //check if the number of items in dateArray is 2 or 1, and assign earlierDate accordingly
        let earlierDate;
        //console.log(dateArray);

        if (dateArray.length === 2) {
          earlierDate = getEarlierDate(dateArray[0], dateArray[1]);
        } else if (dateArray.length === 1) {
          earlierDate = new Date(dateArray[0]);
        }

        // calculate the time difference in minutes
        const caseMinutes = calculateTimeDifferenceInMinutes(earlierDate);

        // highlight the row with different colors based on the time difference
        if (caseMinutes > 90) {
          highlightAnchorWithSpecificContent(row, "rgb(255, 220, 230)")
        } else if (caseMinutes <= 90 && caseMinutes > 60) {
          highlightAnchorWithSpecificContent(row, "rgb(255, 232, 184)")
        } else if (caseMinutes <= 60 && caseMinutes > 30) {
          highlightAnchorWithSpecificContent(row, "rgb(209, 247, 196)")
        } else if (caseMinutes <= 30) {
          highlightAnchorWithSpecificContent(row, "rgb(194, 244, 233)")
        }
      } else {
        unhighlightAnchor(row);
      }
    }
  }
}


// --- CASE STATUS HIGHLIGHTER ---

// > ScholarOne SFDC

/*

<span style="background-color: ${color}!!!; border-radius: 6px; padding: 3px 6px; color: white; font-weight: 500;">Assigned</span>

*/

/*
// find all elements containing CASES_STATUS ids

function findElementsWithIdContainingText() {
  // Get all elements in the document
  var allElements = document.getElementsByTagName("*");

  // Initialize an array to hold the matching elements
  var matchingElements = [];

  // Loop through all elements
  for (var i = 0; i < allElements.length; i++) {
      // If the id of the current element contains "CASES_STATUS"
      if (allElements[i].id.includes("CASES_STATUS")) {
          // Add the current element to the array of matching elements
          matchingElements.push(allElements[i]);
      }
  }

  // Return the array of matching elements
  return matchingElements;
}
*/

/**
 * @description Checks if the current page is the "Cases - Console" page in Salesforce Classic.
 * @returns {boolean} True if the page title matches, false otherwise.
 */
function casePageCheck() {
  var titleElement = document.querySelector("head > title");
  if (titleElement && titleElement.textContent === "Cases - Console") {
    console.log("cases true");
    return true;

  } else {
    return false;
  }
}

/**
 * @description Returns a color code based on the case status text for ScholarOne.
 * @param {string} statusText - The text of the case status.
 * @returns {string} A CSS color string.
 */
function scholarOneStatusColors(statusText) {
  if (statusText === "New" || statusText === "Assigned" || statusText === "Failed QA") {
    return "rgb(191, 39, 75)";
  } else if (statusText === "Waiting" || statusText === "Updated") {
    return "rgb(247, 114, 56)";
  } else if (statusText === "Escalated" || statusText === "On Hold" || statusText === "Pending Approval" || statusText === "Pending QA Review") {
    return "rgb(140, 77, 253)";
  } else if (statusText === "Released" || statusText === "Passed QA" || statusText === "Closed") {
    return "rgb(45, 200, 64)";
  } else if (statusText === "Ready for QA" || statusText === "Ready for DBA" || statusText === "Ready for Data Architect") {
    return "rgb(251, 178, 22)";
  }
}

/**
 * @description Finds all case status elements in ScholarOne SFDC classic and replaces them with a styled span (pill).
 */
function divElementChangerScholarOne() {
  // Get all div elements in the document
  var divElements = document.getElementsByTagName("div");

  // Loop through all div elements
  for (var i = 0; i < divElements.length; i++) {
    // If the id of the current div element contains "CASES_STATUS"

    if (divElements[i].id.includes("CASES_STATUS")) {
      // Create a new span element
      console.log(i);
      var span = document.createElement("span");
      console.log(divElements[i].textContent.trim());


      // Set the style of the span element
      span.style.backgroundColor = scholarOneStatusColors(divElements[i].textContent.trim());
      span.style.borderRadius = "6px";
      span.style.padding = "3px 6px";
      span.style.color = "white";
      span.style.fontWeight = "500";

      // Set the text of the span element to the current text of the div element
      span.textContent = divElements[i].textContent.trim();

      // Clear the current content of the div element
      divElements[i].textContent = "";

      // Append the span element to the div element
      divElements[i].appendChild(span);
    }
  }
}

/**
 * @description Main handler for the ScholarOne case status highlighter. It checks if it's on the correct page
 * and then initializes the highlighting and sets up event listeners to re-apply highlighting on changes.
 */
function scholarOneHandleStatus() {
  if (casePageCheck()) {

    console.log("main function started");

    // runs the backgroundcolourchange for ScholarOne SFDC once initially.
    divElementChangerScholarOne();

    document.querySelector("form").addEventListener('change', function () {

      console.log('The TABLE ELEMENT has changed.');

      divElementChangerScholarOne();



    });

    setTimeout(function () {
      // Your function goes here
      divElementChangerScholarOne();
      console.log("This function runs after 1 second");
    }, 1000);

    console.log("main function finished");
  }
}


// > Lightning SFDC

/**
 * @description Generates a CSS style string for creating a colored "pill" background for status text.
 * @param {string} color - The background color for the pill.
 * @returns {string} The CSS style string.
 */
function generateStyle(color) {
  return `background-color: ${color}; border-radius: 6px; padding: 3px 6px; color: white; font-weight: 500;`;
}

/**
 * @description Main function for the "Case Status Highlighter" feature in Salesforce Lightning.
 * It scans tables for case status cells and applies a colored pill style based on the status text.
 */
function handleStatus() {
  let webTables = document.querySelectorAll('table');

  for (let table of webTables) {
    const rows = table.querySelector('tbody').querySelectorAll('tr');
    for (let row of rows) {
      let cells = row.querySelectorAll('td span span');
      for (let cell of cells) {
        let cellText = cell.textContent.trim();
        if (cellText === "New Email Received" || cellText === "Re-opened" || cellText === "Reopened" || cellText === "Completed by Resolver Group" || cellText === "New" || cellText === "Update Received") {
          cell.setAttribute("style", generateStyle("rgb(191, 39, 75)"));
        } else if (cellText === "Pending Action" || cellText === "Initial Response Sent" || cellText === "In Progress") {
          cell.setAttribute("style", generateStyle("rgb(247, 114, 56)"));
        } else if (cellText === "Assigned to Resolver Group" || cellText === "Pending Internal Response" || cellText === "Pending AM Response" || cellText === "Pending QA Review") {
          cell.setAttribute("style", generateStyle("rgb(140, 77, 253)"));
        } else if (cellText === "Solution Delivered to Customer") {
          cell.setAttribute("style", generateStyle("rgb(45, 200, 64)"));
        } else if (cellText === "Closed" || cellText === "Pending Customer Response") {
          cell.setAttribute("style", generateStyle("rgb(103, 103, 103)"));
        } else if (cellText === "Pending System Update - Defect" || cellText === "Pending System Update - Enhancement" || cellText === "Pending System Update - Other") {
          cell.setAttribute("style", generateStyle("rgb(251, 178, 22)"));
        } else {
          cell.removeAttribute("style");
        }
      }
    }
  }

}

/**
 * @description Highlights the Category and Sub-Category fields with a light yellow color
 * to draw attention to them on the case page.
 */
function highlightCategoryFields() {
  const highlightColor = '#FFFBEA'; // A light, non-intrusive yellow

  // Salesforce labels are often within span elements.
  const allSpans = document.querySelectorAll('span');

  allSpans.forEach(span => {
    const text = span.textContent.trim();
    if (text === 'Category' || text === 'Sub-Category') {
      // The interactive field is typically located within the same 'form-element' container as the label.
      const formElement = span.closest('.slds-form-element');
      if (formElement) {
        // The dropdown is often implemented as a button that opens a combobox.
        const dropdownButton = formElement.querySelector('button.slds-combobox__input');
        if (dropdownButton) {
          dropdownButton.style.backgroundColor = highlightColor;
        }
      }
    }
  });
}


// EVENT LISTENERS FOR EXECUTING FUNCTIONS

// Observe the document for mutations (changes in the DOM)
const observer = new MutationObserver(() => {
  handleAnchors();
  handleCases();
  handleStatus();
  highlightCategoryFields();
});

// Call functions initially - because they use event listener appended to the element instead

// > ScholarOne Mutation Observer
// runs everytime the "option" element changes "selection"

/* // Call functions initially
handleAnchors();
handleCases();
handleStatus(); */

// Observe the document for mutations (changes in the DOM)
observer.observe(document, {
  childList: true,
  subtree: true,
});




